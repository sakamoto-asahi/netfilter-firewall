# netfilter-firewall
netfilter-firewallは、Linuxカーネルのパケット処理フレームワーク`Netfilter`のNFQUEUEターゲットによりIPv4パケットをカーネルからユーザ空間に転送し、`libnetfilter_queue`ライブラリを用いてパケットを解析・処理するファイアウォールです。<br><br>
このファイアウォールはNetfilterに依存するため、**Linux環境でのみ動作します。**<br><br>
本プロジェクトでは、以下の二つのコマンドを提供します。
* `nfw`：ファイアウォール本体。NFQUEUEからパケットを受け取り、ルールに基づいたフィルタリング処理を行います。
* `nfw-ctl`：ファイアウォールの設定変更やルール管理を行う制御用コマンド。UNIXドメインソケット経由で`nfw`と通信します。

## 機能一覧
### パケットフィルタリング
ユーザが定義したルールに基づいて、**プロトコル**/**IPアドレス**/**ポート番号**/**アクション**によるアクセス制御を行います。<br>
※現在は**IPv4**のみに対応しています。
* ルールは**INPUT**と**OUTPUT**のチェインごとに存在します。
* ルールは上から順に評価され、最初に一致したルールが適用されます。
* 一致するルールが存在しなければ、デフォルトポリシーによりアクセス制御が行われます。
### ステートフルインスペクション
**ICMP**、**TCP**、**UDP**のセッション状態を追跡し、既存の通信に対する応答パケットを効率的に許可します。
* 双方向リストでステートテーブルを管理します。
* 定期的にテーブルのエントリーがタイムアウトしていないか確認します。
### ファイアウォール制御コマンド
`nfw-ctl`のサブコマンドにより、実行中のファイアウォールに対してルールや設定を変更することができます。<br>
ルールや設定の変更は、UNIXドメインソケット経由でファイアウォールに安全に反映されます。<br><br>
サブコマンドには以下の命令があります：
* ルールの追加・更新・削除
* ルールのインポート・エクスポート
* デフォルトポリシーの変更
* デフォルトログ設定の変更
* 設定ファイルの再読み込み
* ファイアウォール本体のシャットダウン
### ログ取得機能
パケットの処理結果をログとしてファイルに記録することができます。
* ログには、パケットの情報や取得時間、一致したルールなどが記録されます。
* ログは`log/packet.log`に保存されます。
* ログローテーションにより、一定容量のログが溜まると新しいファイルが作成され、そこにログが記録されます。

## 使用技術
| 技術 | 使用目的 |
| - | - |
| C言語 | ファイアウォール本体および制御コマンドの実装に使用した開発言語。 |
| gcc | C言語のコンパイラ。`-Wall`オプションを用いて詳細な警告を表示する。 |
| Make | ビルドの自動化ツール。`nfw`・`nfw-ctl`のコンパイル、オブジェクトファイルの生成、リンクの自動化を行う。 |
| Docker | 実行環境の統一と配布のため使用。必要なライブラリ・ツールが揃ったLinux環境をコンテナ内に再現し、どの環境でもファイアウォールを動作させることができる。 |
| Netfilter | Linuxカーネルのパケット処理フレームワーク。NFQUEUEターゲットを用いて、パケットをユーザ空間に転送する。 |
| nftables | Netfilterの設定管理ツール。パケットをNFQUEUEへリダイレクトするルールを設定する。 |
| libnetfilter_queue | NFQUEUEに送られてきたパケットをユーザ空間で受信し、解析結果（ACCEPT / DROP）をカーネルに返すためのライブラリ。 |
| POSIXスレッド（pthread） | `nfw`内部で以下の並行処理を実装：<br>・パケット処理スレッド<br>・ステートテーブルのタイムアウトを監視するスレッド<br>・UNIXドメインソケットを介したCLIリクエスト受付スレッド |
| UNIXドメインソケット | `nfw`と`nfw-ctl`のプロセス間通信に使用。ルール更新・設定変更・シャットダウン命令などをリアルタイムに反映できる。 |
| シグナルハンドラ | `SIGINT`や`SIGTERM`を受け取った際、キューとステートテーブルの解放、ソケットとファイルのクローズなどのクリーンアップ処理を行い、異常終了を防止するために使用。 |

## 導入方法
ここでは、netfilter-firewallと実行環境を導入する方法を説明します。<br>
前提として**Git**と**Docker**がインストールされている必要があります。
### 1. ソースコードの取得
Gitがインストールされている環境で以下のコマンドを実行します。
```
git clone https://github.com/sakamoto-asahi/netfilter-firewall.git
cd netfilter-firewall
```
### 2. Dockerイメージのビルド
取得した`Dockerfile`を使ってDockerイメージをビルドします。このステップで、コンテナ内のソースコードがコンパイルされ、プログラムのパスが通ります。
```
docker build -t netfilter-firewall .
```
### 3. ネットワークの作成
テスト時に他のコンテナと通信するためのネットワークを予め作成します。
```
docker network create netfilter-firewall-nw
```
### 4. コンテナの起動
最後に、ビルドしたDockerイメージからコンテナを起動します。
コンテナの起動後、`docker-entrypoint.sh`スクリプトが実行され、`/etc/nftables.conf`に基づいてNFQUEUEへのパケット転送ルールを適用し、その後`bash`シェルが起動されます。<br>
これで環境構築は完了し、netfilter-firewallを実行できます。
```
docker run --name=fw-main --net=netfilter-firewall-nw --cap-add=NET_ADMIN -it netfilter-firewall
```
**【オプション解説】**
* `--name`：コンテナに`fw-main`という名前を付けます。
* `--net`：コンテナが属するネットワークに`netfilter-firewall-nw`を指定します。
* `--cap-add=NET_ADMIN` : NFQUEUEのルール設定を行うための権限をコンテナに付与します。
* `-it` : コンテナを対話モードで起動し、`bash`シェルへアクセスをします。

二回目以降の起動には以下のコマンドを使用します：
```
docker start -ai fw-main
```
作業を終えたら`exit`でシェルを終了し、コンテナを停止します。
```
exit
```
### コンテナ・イメージ・ネットワークの削除方法
不要になったら以下のコマンドで環境を削除してください。
```
# コンテナの削除
docker rm fw-main

# イメージの削除
docker rmi netfilter-firewall

# ネットワークの削除
docker network rm netfilter-firewall-nw
```

## ファイアウォールの実行方法
ファイアウォールの実行には、コンテナを起動しシェルに入った状態で、`nfw`プログラムをバックグラウンドで実行します。
```
nfw &
```
ファイアウォールを終了するには、`nfw-ctl`の`shutdown`コマンドを実行します。<br>
`shutdown`コマンドを実行すると、各スレッドの終了を待ってから、クリーンアップ処理を実行してプログラムが終了します。
```
nfw-ctl shutdown
```

## ファイアウォールの制御コマンド使用方法
`nfw-ctl`は、フィルタリングルールの追加・編集・削除や、ファイアウォールの設定を行うサブコマンドを提供します。コマンドによってはオプションを指定する必要があります。
### nfw-ctlコマンドのオプション
| オプション | 引数 | 説明 |
| - | - | - |
| `-c`, `--chain` | `INPUT`, `OUTPUT` | チェインの指定 |
| `-p`, `--protocol` | `ICMP`, `TCP`, `UDP` または、`ANY` | プロトコルの指定 |
| `-s`, `--src-ip` | `IPアドレス` または、`ANY` | 送信元IPアドレスの指定 |
| `-S`, `--src-port` | `ポート番号` または、`ANY` | 送信元ポート番号の指定 |
| `-d`, `--dst-ip` | `IPアドレス` または、`ANY` | 宛先IPアドレスの指定 |
| `-D`, `--dst-port` | `ポート番号` または、`ANY` | 宛先ポート番号の指定 |
| `-a`, `--action` | `ACCEPT`, `DROP` | パケットのアクションの指定 |
| `-l`, `--log` | `LOG`, `NOLOG` | ログ設定の指定 |
| `-r`, `--rule` | `ENABLED`, `DISABLED` | フィルタリングルールの有効・無効化 |
### ルールの表示（`show`）
`show`コマンドは、現在のフィルタリングルールを**INPUT**と**OUTPUT**に分けて表示します。
```
nfw-ctl show
```
出力結果の例：
```
INPUT (ポリシー：DROP, デフォルトログ：OFF)
番号  プロトコル   送信元アドレス           宛先アドレス            アクション   ログ   有効
----  ----------  ---------------------  ---------------------  ----------  -----  --------
1     TCP         192.168.1.0:ANY        ANY:ANY                ACCEPT      NOLOG  ENABLED
2     UDP         203.0.113.8:8080       ANY:ANY                DROP        NOLOG  ENABLED
3     ICMP        ANY                    ANY                    DROP        LOG    ENABLED

OUTPUT (ポリシー：ACCEPT, デフォルトログ：OFF)
番号  プロトコル   送信元アドレス           宛先アドレス            アクション   ログ   有効
----  ----------  ---------------------  ---------------------  ----------  -----  --------
1     ICMP        ANY                    ANY                    ACCEPT      LOG    ENABLED
2     TCP         ANY:ANY                172.16.0.4:ANY         DROP        NOLOG  DISABLED
```
* `番号`：既存ルールの編集を行う際に指定が必要となる行番号が表示されます。
* `ポリシー`：どのルールとも一致しなかったパケットのデフォルトのアクションが表示されます。
* `デフォルトログ`：どのルールとも一致しなかったパケットのログの有無が表示されます。
### ルールの追加（`add`）
`add`コマンドは、ファイアウォールにフィルタリングルールを追加して適用させます。<br>
引数には、チェイン（-c）とアクション（-a）、ルールの内容をオプションで指定します。<br><br>
外部からのICMPパケットを拒否するルールを追加する例：
```
nfw-ctl add -c INPUT -p ICMP -a DROP
```
### ルールの更新（`update`）
`update`コマンドは、指定したルールの任意の項目を変更してファイアウォールに適用します。<br>
引数には、変更したいルールの行番号とチェイン（-c）、変更内容をオプションで指定します。<br><br>
INPUTチェインの1番目のルールのアクションをDROPに変更する例：
```
nfw-ctl update 1 -c INPUT -a DROP
```
### ルールの削除（`delete`）
`delete`コマンドは、指定したルールを削除してファイアウォールに適用します。<br>
引数には、削除したいルールの行番号とチェイン（-c）を指定します。<br><br>
OUTPUTチェインの一行目のルールを削除する例：
```
nfw-ctl delete 1 -c OUTPUT
```
### すべてのルールを削除（`clear`）
`clear`コマンドは、すべてのルールを削除してファイアウォールに適用します。<br>
引数にチェイン（-c）を指定した場合、指定したチェインのルールだけをすべて削除します。<br>
引数に指定がなければ、INPUTとOUTPUTのすべてのルールを削除します。<br><br>
INPUTチェインのルールをすべて削除する例：
```
nfw-ctl clear -c INPUT
```
### ルールのインポート・エクスポート（`import`, `export`）
`import`コマンドは、外部ルールファイルの内容をインポートしてファイアウォールに適用します。
引数には、外部ファイルのパスを指定します。
```
nfw-ctl import import_file.csv
```
`export`コマンドは、現在のルールを指定したファイルに出力します。
引数には、出力先のファイル名を指定します。
```
nfw-ctl export export_file.csv
```
### デフォルトポリシーの設定（`policy`）
`policy`コマンドは、どのルールとも一致しなかったパケットの処理を設定します。<br>
引数には、チェイン（-c）とアクション（-a）を指定します。<br><br>
INPUTチェインのデフォルトポリシーをDROPに設定する例：
```
nfw-ctl policy -c INPUT -a DROP
```
この設定により、外部からのパケットがどのフィルタリングルールとも一致しなかった場合に拒否されるようになります。
### デフォルトのログ設定（`logging`）
`logging`コマンドは、どのルールとも一致しなかったパケットのログ取得の有無を設定します。<br>
引数には、ログの有無（-l）を表すオプションを指定します。<br><br>
デフォルトログを有効にする例：
```
nfw-ctl logging -l LOG
```
### 設定ファイルの再読み込み（`reload`）
`reload`コマンドは、現在の設定ファイル（`config/firewall.conf`）の内容をファイアウォールに適用させます。
設定ファイルの内容を変更した際に使用します。
```
nfw-ctl reload
```
### ヘルプの表示（`help`）
`help`コマンドからも`nfw-ctl`の使い方を確認できます。
```
nfw-ctl help
```

## ファイアウォールのテスト
ここではファイアウォールが正常に動作するか、実際にパケットの疎通確認を行います。<br>
まずは準備として、通信のためのテスト用コンテナを作成します。新しいターミナルを開き、プロジェクト直下に移動して以下のコマンドを順番に実行してください。以降はファイアウォールが動作するコンテナを**メインコンテナ**、通信相手のテスト用コンテナを**サブコンテナ**と呼びます。
#### 1. サブコンテナのイメージを作成
```
docker build -t firewall-test -f Dockerfile.test .
```
#### 2. サブコンテナの作成（メインコンテナと同じネットワークを指定）
```
docker run --name=test-client --net=netfilter-firewall-nw -it firewall-test
```
### TEST 1 : pingによる疎通確認
ファイアウォールがpingコマンドのICMPパケットをフィルタリングできるか確認します。
#### 1. ファイアウォールの起動とルールの確認
メインコンテナからバックグラウンドでファイアウォールを起動し、現在のフィルタリングルールを確認します。
初期状態では`INPUT`のポリシーが`DROP`のため、外部からの通信は拒否されます。もし、ルールを追加していたり、デフォルトポリシーを変更していた場合は、`nfw-ctl clear`や`nfw-ctl policy`コマンドで戻してください。
```
# メインコンテナ
nfw &
nfw-ctl show
```
#### 2. パケットが拒否されることを確認
メインコンテナのIPアドレスを確認してから、サブコンテナからpingコマンドを入力します。<br>
IPアドレスは、`eth0`の`inet`に表示されているアドレスを使用します。ここで記載しているIPアドレスは実際の環境と違う可能性があるので、実行する際は自分のIPアドレスで試してください。
```
# メインコンテナ
ip a

# 出力例
inet 172.27.0.2/16 brd 172.27.255.255 scope global eth0
```
```
# サブコンテナ
ping 172.27.0.2

# 結果： 0 received, 100% packet loss（疎通失敗）
```
フィルタリングによってpingが拒否されていることが確認できます。
#### 3. ICMPを許可してpingを再実行
ICMPを許可するルールを追加し、通信が通るか検証します。
```
# メインコンテナ
nfw-ctl add -p ICMP -c INPUT -a ACCEPT -l LOG
```
```
# サブコンテナ
ping 172.27.0.2

# 結果: 3 packets transmitted, 3 received, 0% packet loss（疎通成功）
```
ICMPを許可するルールを追加したことで、pingコマンドが成功しました。
#### 4. ログの確認
追加したルールに基づいてログが記録されているか確認します。ログは`log/packet.log`に保存されています。
```
# メインコンテナ
cat log/packet.log

# 出力例
[2026-02-08 20:00:00] INPUT ACCEPT ICMP 172.27.0.3 -> 172.27.0.2 [TYPE: 8, CODE: 0] rule:[INPUT,ICMP,ANY,ANY,ANY,ANY,ACCEPT,LOG,ENABLED]
```
### TEST 2 : ポート番号によるフィルタリング
ファイアウォールのポート番号による制御が正しく機能するか検証します。
#### 1. UDPサーバの準備
メインコンテナで`test/`ディレクトリにある`udp_server`を実行し、UDPサーバを立てます。ポートは`8080`番を開けておきます。
```
# メインコンテナ
cd test
./udp_server 8080
```
#### 2. ルールなしで送信
ルールを追加していない状態で、サブコンテナから`8080`番ポートへパケットを送信します。
```
# サブコンテナ
./udp_client 172.27.0.2 8080

# 実行結果
[20:00:00] パケットを送信しました。応答を待っています...
[20:00:03] タイムアウト：応答がありませんでした。
```
ポリシーが`DROP`のため、ファイアウォールがパケットを拒否しました。
#### 3. ルールを追加して再送信
ファイアウォールで、UDPの`8080`番ポートのみ許可するルールを追加します。その後、先ほどと同じようにメインコンテナでUDPサーバを立て、サブコンテナでパケットを送信します。
```
# メインコンテナ
nfw-ctl add -p UDP -D 8080 -c INPUT -a ACCEPT
./udp_server 8080
```
```
# サブコンテナ
./udp_client 172.27.0.2 8080

# 実行結果
[20:03:00] パケットを送信しました。応答を待っています...
[20:03:00] サーバから応答がありました。
```
ルールを追加したことにより、パケットが返ってきました。
#### 4. 別のポート番号で送信
許可したポート（8080）とは異なるポート（8081）へ送信し、正しく遮断されるか確認します。
```
# メインコンテナ
./udp_server 8081
```
```
# サブコンテナ
./udp_client 172.27.0.2 8081

# 実行結果
[20:05:00] パケットを送信しました。応答を待っています...
[20:05:03] タイムアウト：応答がありませんでした。
```
同じプロトコル（UDP）でも、ポート番号が異なればルールが適用されず遮断されることが確認できました。
### TEST 3 : ステートフルインスペクション
ステートフルインスペクションの機能により、内部（メインコンテナ）から開始した通信に対する外部（サブコンテナ）の応答パケットが、特別なルールを追加しなくても自動的に通過することを確認します。<br>
テスト開始前に、`nfw-ctl clear`でこれまでのルールを削除しておいてください。
#### 1. デフォルトポリシーの確認
ポリシーが`INPUT`は`DROP`なのに対して、`OUTPUT`は`ACCEPT`になっていることを確認してください。<br>
この状態では、内部から外部への通信は許可されますが、外部からの新規通信は拒否されます。
```
# メインコンテナ
nfw-ctl show
INPUT (ポリシー：DROP, デフォルトログ：OFF)
番号  プロトコル   送信元アドレス           宛先アドレス            アクション   ログ   有効
----  ----------  ---------------------  ---------------------  ----------  -----  --------

OUTPUT (ポリシー：ACCEPT, デフォルトログ：OFF)
番号  プロトコル   送信元アドレス           宛先アドレス            アクション   ログ   有効
----  ----------  ---------------------  ---------------------  ----------  -----  --------
```
#### 2. 外部からの通信を拒否することを確認
```
# メインコンテナ
./udp_server 8080
```
```
# サブコンテナ
./udp_client 172.27.0.2 8080

# 実行結果
[20:08:00] パケットを送信しました。応答を待っています...
[20:08:03] タイムアウト：応答がありませんでした。
```
`INPUT`のデフォルトポリシーが`DROP`のため、外部からの通信は拒否されました。
#### 3. 内部からの通信に対する外部パケットの疎通確認
メインコンテナのパケットに対する、サブコンテナの応答パケットが通ることを確認します。
今度はサブコンテナがサーバを立て、メインコンテナがパケットを送信します。
```
# サブコンテナ
./udp_server 8080
```
```
# メインコンテナ
./udp_client 172.27.0.3 8080

# 実行結果
[20:10:00] パケットを送信しました。応答を待っています...
[20:10:00] サーバから応答がありました。
```
#### なぜ応答パケットが通るのか
ファイアウォールはメインコンテナから外部へ出ていくパケットをフィルタリングルールによって許可されていることを確認すると、`プロトコル`、`送信元・宛先IP`、`送信元・宛先ポート番号`などのパケット情報をステートテーブルに保存します。その後、サブコンテナから応答パケットが届くと、ファイアウォールはそのパケットを解析し、ステートテーブルと照合します。既に存在するセッションの続きであると判断されると、フィルタリングルールよりも優先してパケットを通過させます。これにより、`INPUT`ポリシーが`DROP`の状態でも内部からの通信に対する応答は正常に受信できます。

### テスト環境の破棄
テスト終了したら以下のコマンドで環境を削除してください。
```
docker rm test-client  # コンテナの削除
docker rmi firewall-test  # イメージの削除
docker network rm netfilter-firewall-nw  # ネットワークの削除
```